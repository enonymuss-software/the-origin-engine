<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Origin Engine - High Contrast Ecosystem</title>
    <style>
        body { margin: 0; background-color: #000; color: #00ffcc; font-family: 'Courier New', monospace; overflow: hidden; }
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            background: rgba(0, 10, 10, 0.9); padding: 20px; 
            border: 1px solid #00ffcc; border-radius: 5px;
            pointer-events: auto; width: 280px; box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        .status-text { font-size: 1.2rem; font-weight: bold; margin-bottom: 5px; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        #system-readout { font-size: 1.1rem; margin-bottom: 15px; color: #00ffcc; font-weight: bold; border-bottom: 1px solid #004444; padding-bottom: 10px; }
        .legend { margin: 15px 0; font-size: 0.75rem; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; box-shadow: 0 0 5px currentColor; }
        .about-section { font-size: 0.7rem; color: #88aaaa; line-height: 1.4; margin-top: 15px; border-top: 1px solid #004444; padding-top: 10px; }
        label { display: block; margin-top: 10px; color: #00ffcc; font-size: 0.7rem; letter-spacing: 1px; font-weight: bold; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #00ffcc; margin-bottom: 5px; }
        button { 
            width: 100%; margin-top: 15px; background: #004444; border: 1px solid #00ffcc; 
            color: #00ffcc; padding: 10px; cursor: pointer; font-family: inherit; font-weight: bold; text-transform: uppercase;
        }
        button:hover { background: #00ffcc; color: #050505; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status-text">Origin Engine</div>
        <div id="system-readout">POPULATION: 0</div>

        <div class="legend">
            <div class="legend-item"><div class="dot" style="background: #00ffcc; color: #00ffcc;"></div> TEAL: GRAZING (Neutral)</div>
            <div class="legend-item"><div class="dot" style="background: #ff00ff; color: #ff00ff;"></div> PINK: MATING (High Energy)</div>
            <div class="legend-item"><div class="dot" style="background: #ffff00; color: #ffff00;"></div> YELLOW: SWIMMING (Panic)</div>
        </div>

        <label>WORLD ROTATION</label>
        <input type="range" id="speedSlider" min="0" max="0.01" step="0.0001" value="0.0003">
        
        <label>METABOLISM (Consumption Rate)</label>
        <input type="range" id="lifeSlider" min="0.005" max="0.1" step="0.001" value="0.02">
        
        <label>SEA LEVEL (Flood Control)</label>
        <input type="range" id="seaSlider" min="-1.5" max="2" step="0.1" value="-0.5">

        <button id="reseedBtn">Reseed Population</button>

        <div class="about-section">
            <strong>SYSTEM LOGIC:</strong><br>
            Life-forms consume green biomass to gain energy. High energy triggers asexual budding. Submergence or lack of vegetation leads to energy depletion and death. Terrain and life are generated purely via deterministic algorithms.
        </div>
    </div>

    <div id="world-container"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 18);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('world-container').appendChild(renderer.domElement);

        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 2);
        sun.position.set(5, 15, 7);
        scene.add(sun);

        // --- TERRAIN & RESOURCES ---
        const size = 20, segments = 80;
        const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
        const terrain = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: true }));
        terrain.rotation.x = -Math.PI / 2;
        worldGroup.add(terrain);

        const vertexCount = geometry.attributes.position.count;
        const grassHealth = new Float32Array(vertexCount).fill(1.0);

        // --- LIFE FORMS ---
        let particles = [];
        const maxPop = 1500;
        const pGeometry = new THREE.BufferGeometry();
        const pMaterial = new THREE.PointsMaterial({ 
            size: 0.35, 
            vertexColors: true, 
            transparent: true, 
            opacity: 1.0,
            blending: THREE.AdditiveBlending 
        });
        
        const lifeForms = new THREE.Points(pGeometry, pMaterial);
        worldGroup.add(lifeForms);

        function spawn(count, boost = false) {
            for (let i = 0; i < count; i++) {
                particles.push({ 
                    x: (Math.random()-0.5)*12, 
                    z: (Math.random()-0.5)*12, 
                    energy: boost ? 150 : 100 
                });
            }
        }
        spawn(250, true);

        const sSpeed = document.getElementById('speedSlider');
        const sLife = document.getElementById('lifeSlider');
        const sSea = document.getElementById('seaSlider');
        const readout = document.getElementById('system-readout');
        document.getElementById('reseedBtn').onclick = () => spawn(100, true);

        function animate() {
            requestAnimationFrame(animate);
            const water = parseFloat(sSea.value), metabolism = parseFloat(sLife.value);

            const pos = geometry.attributes.position.array;
            const colors = [];
            const tempC = new THREE.Color();

            for (let i = 0; i < vertexCount; i++) {
                const vx = pos[i*3], vy = pos[i*3+1];
                const h = Math.sin(vx*0.4)*Math.cos(vy*0.4)*2 + Math.sin(vx*2.0)*0.2;
                pos[i*3+2] = h;

                if (grassHealth[i] < 1.0) grassHealth[i] += 0.0025;

                if (h < water) tempC.setHex(0x0022aa); 
                else if (h < water + 0.1) tempC.setHex(0xd2b48c);
                else if (h < 1.5) {
                    tempC.setRGB(0.1 + (1 - grassHealth[i])*0.2, 0.8 * grassHealth[i], 0.2 * grassHealth[i]);
                } else tempC.setHex(0xffffff);
                
                colors.push(tempC.r, tempC.g, tempC.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            const nextGen = [], drawPos = [], drawCol = [], pCol = new THREE.Color();
            if (particles.length > 0 && particles.length < 5) spawn(15, true);

            for (let p of particles) {
                const landH = Math.sin(p.x*0.4)*Math.cos(p.z*0.4)*2 + Math.sin(p.x*2.0)*0.2;
                const inWater = landH < water;
                const speed = inWater ? 4 : 1;
                
                p.x += (Math.random()-0.5) * metabolism * speed;
                p.z += (Math.random()-0.5) * metabolism * speed;

                const gridX = Math.round(((p.x + size/2) / size) * segments);
                const gridZ = Math.round(((p.z + size/2) / size) * segments);
                const vIdx = Math.max(0, Math.min(vertexCount - 1, gridZ * (segments + 1) + gridX));

                if (!inWater && landH < 1.5 && grassHealth[vIdx] > 0.2) {
                    p.energy += 2.5; 
                    grassHealth[vIdx] -= 0.035; 
                } else {
                    p.energy -= 0.7; 
                }

                if (p.energy > 200 && nextGen.length < maxPop) {
                    p.energy = 90; 
                    nextGen.push({ x: p.x, z: p.z, energy: 90 });
                }

                if (p.energy > 0) {
                    nextGen.push(p);
                    drawPos.push(p.x, Math.max(landH, water)+0.2, p.z);
                    
                    // --- COLOR LOGIC UPDATED TO YELLOW ---
                    if (p.energy > 165) pCol.setHex(0xff00ff); // Mating
                    else if (inWater) pCol.setHex(0xffff00);   // Swimming (YELLOW)
                    else pCol.setHex(0x00ffcc);                // Grazing
                    
                    drawCol.push(pCol.r, pCol.g, pCol.b);
                }
                
                if (Math.abs(p.x) > 9.8) p.x *= -0.98;
                if (Math.abs(p.z) > 9.8) p.z *= -0.98;
            }

            particles = nextGen;
            pGeometry.setAttribute('position', new THREE.Float32BufferAttribute(drawPos, 3));
            pGeometry.setAttribute('color', new THREE.Float32BufferAttribute(drawCol, 3));
            readout.innerText = `POPULATION: ${particles.length}`;

            worldGroup.rotation.y += parseFloat(sSpeed.value);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
